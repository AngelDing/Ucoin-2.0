using System;
using System.Data.Entity;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using Ucoin.Conference.Contracts.Events.Registration;
using Ucoin.Conference.EfData;
using Ucoin.Conference.Entities;
using Ucoin.Conference.Repositories;
using Ucoin.Framework.Messaging.Handling;
using Ucoin.Framework.Repositories;

namespace Ucoin.Conference.Services
{
    // This denormalized version of an order is being created in the Conference Management BC, via events
    // coming from the Registration BC (generated by event sourced aggregates).
    // ALL the information is there to generate this denormalized version, but nevertheless, the events
    // seem too granular to keep up with, considering this is a different and isolated bounded context.

    // We feel that reusing the same events that the Registration BC uses internally (for both event sourcing
    // in the write-model, and generating projections for the read model) for integrating between different
    // BCs starts to make the 2 BCs very coupled (regardless of that coupling being through messaging).

    // An alternative is that the Registration BC can create a denormalization like this one on "the other side",
    // and at one point in time publish an event specifically made for integration, with a full dump
    // of the order information.
    // A slightly different alternative, is that we generate the projection on the other side, and publish
    // an event notifying the listeners that a new order is ready, so they (the Conference Mgmt BC)
    // can (asynchronously) make a direct service call and get the information for the order
    // (still getting the fully denormalized order in a single service call).

    // The advisors agreed that handling this many events is OK nevertheless.
    public class OrderEventHandler :
        IEventHandler<OrderPlaced>,
        IEventHandler<OrderRegistrantAssigned>,
        IEventHandler<OrderTotalsCalculated>,
        IEventHandler<OrderConfirmed>,
        IEventHandler<OrderExpired>,
        IEventHandler<SeatAssignmentsCreated>,
        IEventHandler<SeatAssigned>,
        IEventHandler<SeatAssignmentUpdated>,
        IEventHandler<SeatUnassigned>
    {
        private IOrderRepository orderRepository;
        private IRepositoryContext context;

        public OrderEventHandler(IRepositoryContext context, IOrderRepository orderRepository)
        {
            this.context = context;
            this.orderRepository = orderRepository;
        }

        public void Handle(OrderPlaced @event)
        {
            context.RegisterNew(new Order(@event.ConferenceId, @event.SourceId, @event.AccessCode));
            context.Commit();
        }

        public void Handle(OrderRegistrantAssigned @event)
        {
            ProcessOrder(order => order.Id == @event.SourceId, order =>
            {
                order.RegistrantEmail = @event.Email;
                order.RegistrantName = @event.LastName + ", " + @event.FirstName;
            });
        }

        public void Handle(OrderTotalsCalculated @event)
        {
            if (!ProcessOrder(order => order.Id == @event.SourceId, order => order.TotalAmount = @event.Total))
            {
                Trace.TraceError("Failed to locate the order with id {0} to apply calculated totals", @event.SourceId);
            }
        }

        public void Handle(OrderConfirmed @event)
        {
            if (!ProcessOrder(order => order.Id == @event.SourceId, order => order.Status = Order.OrderStatus.Paid))
            {
                Trace.TraceError("Failed to locate the order with {0} to apply confirmed payment.", @event.SourceId);
            }
        }

        public void Handle(OrderExpired @event)
        {
            var order = this.orderRepository.GetBy(x => x.Id == @event.SourceId).FirstOrDefault();
            if (order != null)
            {
                context.RegisterDeleted(order);
                context.Commit();
            }
        }

        public void Handle(SeatAssignmentsCreated @event)
        {
            if (!ProcessOrder(order => order.Id == @event.OrderId, order => order.AssignmentsId = @event.SourceId))
            {
                Trace.TraceError("Failed to locate the order with {0} for the seat assignments being created with id {1}.", @event.OrderId, @event.SourceId);
            }
        }

        public void Handle(SeatAssigned @event)
        {
            if (!ProcessOrder(order => order.AssignmentsId == @event.SourceId, order =>
            {
                var seat = order.Seats.FirstOrDefault(x => x.Position == @event.Position);
                if (seat != null)
                {
                    seat.Attendee.FirstName = @event.Attendee.FirstName;
                    seat.Attendee.LastName = @event.Attendee.LastName;
                    seat.Attendee.Email = @event.Attendee.Email;
                }
                else
                {
                    order.Seats.Add(new OrderSeat(@event.SourceId, @event.Position, @event.SeatType)
                    {
                        Attendee = new Attendee
                        {
                            FirstName = @event.Attendee.FirstName,
                            LastName = @event.Attendee.LastName,
                            Email = @event.Attendee.Email,
                        }
                    });
                }
            }))
            {
                Trace.TraceError("Failed to locate the order with seat assignments id {0} for the seat assignment being assigned at position {1}.", @event.SourceId, @event.Position);
            }
        }

        public void Handle(SeatAssignmentUpdated @event)
        {
            if (!ProcessOrder(order => order.AssignmentsId == @event.SourceId, order =>
            {
                var seat = order.Seats.FirstOrDefault(x => x.Position == @event.Position);
                if (seat != null)
                {
                    seat.Attendee.FirstName = @event.Attendee.FirstName;
                    seat.Attendee.LastName = @event.Attendee.LastName;
                }
                else
                {
                    Trace.TraceError("Failed to locate the seat being updated at position {0} for assignment {1}.", @event.Position, @event.SourceId);
                }
            }))
            {
                Trace.TraceError("Failed to locate the order with seat assignments id {0} for the seat assignment being updated at position {1}.", @event.SourceId, @event.Position);
            }
        }

        public void Handle(SeatUnassigned @event)
        {
            if (!ProcessOrder(order => order.AssignmentsId == @event.SourceId, order =>
            {
                var seat = order.Seats.FirstOrDefault(x => x.Position == @event.Position);
                if (seat != null)
                {
                    order.Seats.Remove(seat);
                }
                else
                {
                    Trace.TraceError("Failed to locate the seat being unassigned at position {0} for assignment {1}.", @event.Position, @event.SourceId);
                }
            }))
            {
                Trace.TraceError("Failed to locate the order with seat assignments id {0} for the seat being unassigned at position {1}.", @event.SourceId, @event.Position);
            }
        }

        private bool ProcessOrder(Expression<Func<Order, bool>> lookup, Action<Order> orderAction)
        {
            var order = orderRepository.FindOrder(lookup);
            if (order != null)
            {
                orderAction.Invoke(order);
                context.Commit();
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
